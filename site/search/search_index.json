{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Exercise Solution to Lab(2): Data Parallism","text":"<p>I will present to you the data partition table for the improved data distribution along with a suggested implementation.</p> <p><code>Data size = 48</code></p> <p><code>Number of processors = 4</code></p>"},{"location":"#distribution-table","title":"Distribution table","text":"P0 P1 P2 P3 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 27 26 25 24 31 30 29 28 35 34 33 32 39 38 37 36 43 42 41 40 47 46 45 44 <p>Notice that the summation of the total Fibonacci number calculated by each processor is equal.</p> <p><code>To calculate fib(n), we need to calculate fibonacci numbers from 0 to n-2, n-1, so we calculate n fibonacci numbers.</code></p> <p>lets us explain how?</p> <p><code>P0 :</code> <code>(0 + 47) + (4 + 43) + (8 + 39) + (12 + 35) + (16 + 31) + (20 + 27) = 282</code></p> <p><code>P1 :</code> <code>(1 + 46 ) + (5 + 42) + (9 + 38) + (13 + 34) + (17 + 30) + (21 + 26) = 282</code></p> <p><code>P2 :</code> <code>(2 + 45 ) + (6 + 41) + (10 + 37) + (14 + 33) + (18 + 29) + (22 + 25) = 282</code></p> <p><code>P3 :</code> <code>(3 + 44 ) + (7 + 40) + (11 + 36) + (15 + 32) + (19 + 28) + (23 + 24) = 282</code></p> <p>So the total Fibonacci numbers calculated by each processor are equal (<code>282</code>).</p>"},{"location":"#cpp-code-implementaion","title":"CPP code implementaion","text":"<p>Here is the full code for fib, I modified the fib code.</p> <p><pre><code>#include &lt;iostream&gt;\n#include &lt;pthread.h&gt;\n#include &lt;chrono&gt;\n\nusing namespace std;\n\nconst int N = 48;   // data size\nconst int NP = 4;   // number of processors\n\nunsigned long long fib (unsigned int);\nvoid computeFib (int);\n\nint main()\n{\n    pthread_t t0, t1, t2, t3;\n    using clock = std::chrono::steady_clock;\n    clock::time_point start = clock::now();\n\n    pthread_create(&amp;t0, NULL, (void *(*)(void *))computeFib, (void *)0);\n    pthread_create(&amp;t1, NULL, (void *(*)(void *))computeFib, (void *)1);\n    pthread_create(&amp;t2, NULL, (void *(*)(void *))computeFib, (void *)2);\n    pthread_create(&amp;t3, NULL, (void *(*)(void *))computeFib, (void *)3);\n\n    pthread_join(t0, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    pthread_join(t3, NULL);\n\n    clock::time_point end = clock::now();\n\n    clock::duration execution_time = end - start;\n    std::cout &lt;&lt; \"Execution time is \" \n              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(execution_time).count() \n              &lt;&lt; \"ms.\" &lt;&lt; std::endl;\n\n    return 0;\n}\n\nvoid computeFib(int id)\n{\n\n    cout &lt;&lt; \"Processor (\" &lt;&lt; id &lt;&lt; \") started ...\" &lt;&lt; endl;\n\n    int start = id;\n    int end = N;\n    int mid = (end + 1) / 2;\n    // distribute the number from 0 to 23 among processor\n    for (int n = start; n &lt; mid; n += NP)\n        cout &lt;&lt; \"fib(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; fib(n) &lt;&lt; endl;\n    // distribute the number from 47 to 24 among processor\n    for (int n = (end - id - 1); n &gt;= mid; n -= NP)\n        cout &lt;&lt; \"fib(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; fib(n) &lt;&lt; endl;\n\n    cout &lt;&lt; \"Processor (\" &lt;&lt; id &lt;&lt; \") finished.\" &lt;&lt; endl;\n}\n\nunsigned long long fib(unsigned int n)\n{\n    if (n &lt;= 1)\n        return 1;\n    else\n        return fib(n-1) + fib(n-2);\n}\n</code></pre> The idea is to distribute numbers from <code>0 to 23</code> among processors.</p> <p><code>for (int n = start; n &lt; mid; n += NP)</code></p> <p>Then distribute number from <code>47 to 24</code>.</p> <p><code>for (int n = (end - id - 1); n &gt;= mid; n -= NP)</code></p> <p> Notes: You can achieve butter implementation by optimizing the fib function also See this fib algrithms. </p>"},{"location":"about/","title":"Exercise Solution to Lab(3): Preserving Dependency","text":""},{"location":"about/#pi-estimation-use-monte-carlo-method","title":"PI estimation use  Monte Carlo method","text":"<p>Monte Carlo methods are subset of computational algorithms that use the process of repeated random sampling to make numerical estimations of unknown parameters.</p>"},{"location":"about/#how-to-estimate-pi-use-mote-carlo-method","title":"How to estimate PI use Mote Carlo method?","text":"<p>The idea is to simulate random (x, y) points (the points are below to the uniform distribution) in a 2-D plane with the domain as a square of side 2r units centered on (0.0) and draw a circle with radious r inside the square. Then we calculate the ratio of number points that lied inside the circle and the total number of generated points.</p> \\[ \\text{Area of the circle} = \\pi r^2 \\] \\[ \\text{Area of the square} =  2r * 2r = 4r^2 \\] \\[ \\frac{\\text{Area of the circle}}{\\text{Area of the square}} = \\frac{\\pi}{4} \\] \\[ \\pi = 4 * \\frac{\\text{Area of the circle}}{\\text{Area of the square}} \\]"},{"location":"about/#cpp-code-to-estimate-pi","title":"CPP code to estimate PI","text":"<pre><code>#define _USE_MATH_DEFINES\n\n#include &lt;pthread.h&gt;\n#include &lt;chrono&gt;\n#include &lt;math.h&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n\nusing namespace::std;\n\nconstexpr unsigned long long number_of_tosses = 1'000'000'000;\nconstexpr int NP = 4; // 8, 16, 32, ...\nunsigned long long block_length = number_of_tosses / NP;\nunsigned long long sum[NP]; /* Array to store the sum for each thread */\n/* Thread-local random number generator */\nthread_local std::mt19937 generator(std::random_device{}());\n\n/* Function to generate a random number in the range [-1.0, 1.0] */\ndouble random_num_generator() {\n  static thread_local std::uniform_real_distribution&lt;&gt; dis(-1.0, 1.0);\n  return dis(generator);\n}\n\n/* Function to calculate the square of the distance from the origin */\ndouble distance_square() {\n  double x, y;\n\n  x = random_num_generator();\n  y = random_num_generator();\n\n  return x * x + y * y;\n}\n\n/* Thread function to compute the number of points inside the circle */\nvoid *computePI(void *tid) {\n  int id = (int)(uintptr_t)tid;\n  unsigned long long toss;\n  unsigned long long my_sum = 0;\n  double square_root;\n\n  for (toss = 0; toss &lt; block_length; toss++) {\n    square_root = distance_square();\n    if (square_root &lt;= 1) {\n      my_sum++;\n    }\n  }\n\n  sum[id] = my_sum;\n  return nullptr;\n}\n\nint main(int argc, char **argv) {\n  pthread_t tid[NP];\n  unsigned long long number_in_circle = 0;\n  double pi_estimate;\n  using clock = std::chrono::steady_clock;\n  clock::time_point start = clock::now();\n\n  /* Create threads */\n  for (int i = 0; i &lt; NP; i++) {\n    pthread_create(&amp;tid[i], nullptr, computePI, (void *)(uintptr_t)i);\n  }\n\n  /* Wait for all threads to finish */\n  for (int i = 0; i &lt; NP; i++) {\n    pthread_join(tid[i], nullptr);\n  }\n\n  /* Sum up the results from all threads */\n  for (int i = 0; i &lt; NP; i++) {\n    number_in_circle += sum[i];\n  }\n\n  pi_estimate = 4.0 * number_in_circle / static_cast&lt;double&gt;(number_of_tosses);\n  cout &lt;&lt; \"PI estimate: \" &lt;&lt; std::setprecision(15) &lt;&lt; pi_estimate &lt;&lt; endl;\n\n  clock::time_point end = clock::now();\n\n  clock::duration execution_time = end - start;\n  cout &lt;&lt; \"Execution time is \"\n       &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(execution_time)\n              .count()\n       &lt;&lt; \"ms.\" &lt;&lt; endl;\n  cout &lt;&lt; \"value of PI is = \" &lt;&lt; M_PI &lt;&lt; endl;\n\n  return 0;\n}\n</code></pre> <p>Let us break the code !!</p> <ol> <li> <p>Generate random number</p> <p>I include the <code>&lt;random&gt;</code> header to use std::mt19937 Mersenne Twister random number engine to generate high-quality pseudo-random numbers.</p> <p>Create a mt19937 engine to generate a random number locally for each thread.</p> <p><code>thread_local std::mt19937 generator(std::random_device{}());</code></p> <p>Create objects <code>dis</code> that are uniformly distributed in the <code>range(-1.0, 1.0)</code> and are once initiated per thread (<code>static thread_local</code>). Then use the generator with <code>dis</code> to generate random numbers.</p> <pre><code>double random_num_generator() {\n    static thread_local std::uniform_real_distribution&lt;&gt; dis(-1.0, 1.0);\n    return dis(generator);\n}\n</code></pre> </li> <li> <p>Compute distance square to check if the point falls inside the circle or not: <code>distance_square()</code>.</p> </li> <li> <p><code>computePI</code> is thread function to compute the number of points inside the circle. Here I divide the random number generation among threads and let each thread generate \\(\\frac{N}{NP}\\) points and sum the total number of points inside the circle, then store it in the array with the id of the process.</p> </li> <li> <p>In the main function I create the thread and let them wait to all finish after that let the master thread sum the total numbers of point inside the circle and estimate <code>PI</code>.</p> </li> </ol> <p> Notes: Here I use Array to store the number of points inside the circle generated by each process, but you can also use Vector. Or you can directly update the number_in_circle using mutex (see your lecture notes). </p>"}]}